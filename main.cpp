//
//  main.cpp
//  packet_autobahn
//
//  Created by Leon Eckert on 11/03/2016.
//  Copyright Â© 2016 Leon Eckert. All rights reserved.
//


#include <iostream>
#include <tins/tins.h>
#include <vector>
#include <string>
#include <sstream>
#include <map>
#include <ncurses.h>


using namespace Tins;
using namespace std;

////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////[ Get Src ]///////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_src_from_pdu(const PDU &pdu){
    const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
    string src = dot11Data.src_addr().to_string();
    return src;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////[ Get Timestamp ]/////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////

string get_timestamp_from_pkt(const Packet& pkt){
//    long timestamp = pkt.timestamp().seconds();
    string ts;
    stringstream strstream;
    strstream << pkt.timestamp().seconds();
    strstream >> ts;
    return ts;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
////[ Get Requested Info from Data11 pkt ]//////
////////////////////////////////////////////////
////////////////////////////////////////////////
vector<string> returnFromData11(const Packet& pkt){
    vector<string> output;
    // here is where we do stuff with packets:
    const PDU& pdu = *pkt.pdu();
    
    // if yes, get the rawPDU and do something with it
    try{
        
        string MAC = get_src_from_pdu(pdu);
        output.push_back(MAC);
        string timestamp = get_timestamp_from_pkt(pkt);
        output.push_back(timestamp);
        
    }catch(...){}
    
    return output;
    
}





map<string, pair<int, long>> activeMACs;
//map<string, vector<int>> MACcolors;
//vector<string> orderedMACs;


void wipeData(){
    for(auto& x : activeMACs){
        x.second.first = 0;
    }
}
long currentTime(){
    time_t  timev;
    return time(&timev);
}

string isActive(const string& MAC, long KillThreshold){
    if (currentTime() - activeMACs[MAC].second >= KillThreshold){
        return "NO";
    }else{
        return "YES";
    }
}

void processData(vector<string> data){
    if (data.size() == 2) {
        string MAC = data[0];
        long timestamp = stol( data[1]);
        
        if (activeMACs.find(MAC) == activeMACs.end()) {
//            generate a color here and assign to thing:
            //not found:
            pair <int,long> p (1,timestamp);
            activeMACs[MAC] = p;
//            push color into here: MACcolors(MAC)
            
//            orderedMACs.push_back(MAC);
            // perhaps also put on ordered array
        }else{
            //found:
            activeMACs[MAC].first += 1;
            activeMACs[MAC].second = timestamp;
        }
    }
}


void printData(){
    string s = ":";
    for(auto x : activeMACs){
        //        cout << x.first << ": ";
        if (s == ":") {
            s = "|";
        }else if (s == "|"){
            s = ":";
        }
        for(int j = 0; j < x.second.first/3; j++){
            //            cout << "|";
            cout << s;
        }
    }
    cout << endl;
}

void printDataNC(){
    start_color();
    init_pair(1,COLOR_RED, COLOR_BLACK);
    init_pair(2,COLOR_CYAN, COLOR_BLACK);
    init_pair(3,COLOR_YELLOW, COLOR_BLACK);
    
    int a = 1;
    for(auto x : activeMACs){
        if (a == 1) {
            attron(COLOR_PAIR(1));
            a++;
        }else if (a == 2){
            attron(COLOR_PAIR(2));
            a++;
        }else if (a == 3){
            attron(COLOR_PAIR(3));
            a = 1;
        }
        attron(A_BOLD);
        
        
        for(int j = 0; j < x.second.first/3; j++){
            
            printw("|");
            
            
        }
        attroff(COLOR_PAIR(1));
        attroff(A_BOLD);
        refresh();
    }
    printw("\n");
    //    cout << endl;
    
    
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void startSniffing(std::string _interface, bool monitorMode){
    
    // configure the sniffer:
    std::string interface = _interface;
    SnifferConfiguration config;
    config.set_promisc_mode(true);
    config.set_rfmon(monitorMode);
    Sniffer sniffer(interface, config);
    
    
    
    // now sniff:
//    int print_interval = 1; // in seconds
//    long timeTrack = currentTime();
    
    try {
        int c = 0;
        while(Packet pkt = sniffer.next_packet()) {
            
            vector<string> pktData = returnFromData11(pkt);
//            for (auto& s : pktData){
//                cout << s << endl;
//            }
            processData(pktData); //creates map with times
            for (auto& s : activeMACs){
                cout << s.first << " || last active: " << currentTime() - s.second.second << " seconds ago" << " || active: " << isActive(s.first, 10) << endl;
            }
            cout << "-----------" << endl;
//            updateDataMap(10); // takes out non active MACs
//
//            
//            
//            if (c > 600){
//                printDataNC();
//                c = 0;
//                wipeData();
//            }
//            c ++;
            
//            if (currentTime() - timeTrack > print_interval){
//                printDataNC();
//                wipeData();
//                timeTrack = currentTime();
//            }

            
        }
    }catch(...){}
    
    

}

int main(){
    //ncurses:
//    initscr();
//    curs_set(0);
//    scrollok(stdscr, TRUE);
    
    startSniffing("en0", true);
    
//    getch();
//    endwin();
//    return 0;
}